/*   
    Copyright 2006, Astrophysics Research Institute, Liverpool John Moores University.

    This file is part of Robotic Control System.

     Robotic Control Systemis free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    Robotic Control System is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Robotic Control System; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/
package ngat.rcs.emm;

import ngat.rcs.*;
import ngat.rcs.tms.*;
import ngat.rcs.tms.executive.*;
import ngat.rcs.tms.manager.*;
import ngat.rcs.oldscience.*;
import ngat.rcs.oldstatemodel.*;
import ngat.rcs.scm.*;
import ngat.rcs.scm.collation.*;
import ngat.rcs.scm.detection.*;
import ngat.rcs.comms.*;
import ngat.rcs.control.*;
import ngat.rcs.iss.*;
import ngat.rcs.tocs.*;
import ngat.rcs.calib.*;

import java.util.*;

/** Provides a location for classes to subscribe (unsubscribe)
 * to classes of Event which may be generated by the RCS monitoring
 * sub-system. Monitors publish (post) events of various types
 * to the EventQueue when certain conditions occur - typically these
 * are alerts which subscribing classes need to know about in order 
 * to take appropriate preventative or recovery action. 
 * <p>
 * A thread - the EventDespatcher examines this queue regularly 
 * (configurable parameter) and despatches notifications to the 
 * relevant subscribers as neccessary. A subscriber may subscribe 
 * to as many event types as it wants to and many different
 * subscribers can subscribe to a given event type. 
 * <p>
 * In the interests of efficiency, subscribers should unsubscribe 
 * to events as soon as they are no longer interested in them as 
 * the notification action takes up valuable cpu cycles needlessly 
 * if they are just going to ignore them - this decision would be 
 * determined by the subscriber's internal state.
 * <p>
 * The Events are arranged as a tree of <i>topics</i> - a subscriber
 * can subscribe to any point in the tree and will be notified if
 * a topic at any point below in the tree is published.
 * E.g. A subscriber to <b>alerts</b> would receive notification of
 * events such as <b>alerts</b>, <b>alerts.rain</b>, <b>alerts.rain.heavy</b>
 * and <b>alerts.wind.north.gusting</b> etc. Note however that the subscriber
 * only receives ONE notification - i.e. they get the notification of the 
 * actual event not of the higher level events they subscribed to.
 *
 * <br><br> 
 * <dl>
 * <dt><b>Source:</b>
 * <dd>$Source: /home/dev/src/rcs/java/ngat/rcs/emm/RCS/EventRegistry.java,v $
 * </dl>
 * @author $Author: snf $
 * @version $Revision: 1.1 $
 * <br><br>
 * $Id: EventRegistry.java,v 1.1 2006/12/12 08:29:47 snf Exp $
 */

public class EventRegistry {
    
    /** Internal structure for storing subscriber lists.*/
    protected Map registry;
    
    /** The singleton instance.*/
    protected static EventRegistry instance = null;
    
    /** Create an EventRegistry.*/
    private EventRegistry() {
	registry = Collections.synchronizedMap(new HashMap());
    }
    
    /** @return The singleton instance.*/
    public static EventRegistry getInstance() {
	if (instance == null)
	    instance = new EventRegistry();
	return instance;
    }
    
    /** Register a specified EventID - creates a new Vector to
     * hold the List of Subscribers for this event.
     * If the event is already registered this has no effect -
     * i.e. the subscriber list is not zapped. There is generally
     * no reason for this to be called as it is invoked whenever
     * a Subscriber subscribes to a new event code. 
     * @paramtopic The topic as specified in EventID for
     * which to create an entry.
     */
    public static void registerEvent(String topic) {
	if (instance.registry.get(topic) == null)
	    instance.registry.put(topic, new Vector());
    }

    

    /** Subscribe the specified Subscriber to the specified EventId.
     * If the subscriber has already subscribed to this event it is
     * not added again - i.e. a Subscriber can only subscribe once to
     * any given EventID this prevents it being notified more than
     * once when an event is actually fired. If the event specified
     * by eventId has not yet been registered then an entry is made
     * for it in the table.
     * @param topic The topic to subscribe to.
     * @param subscriber The Subscriber to add.
     */
    public static void subscribe(String topic, EventSubscriber subscriber) {
	System.err.println("EMM: Subscribe: "+topic+" For: "+subscriber);
	// Create an entry for subscriber if none already.
	if (instance.registry.get(subscriber) == null) {
	    List list =  new Vector();
	    list.add(topic);
	    instance.registry.put(subscriber, list);	    
	    return;
	}
	// If already subscribed - exit.
	List list = (List)instance.registry.get(subscriber);
	if (list.contains(topic))
	    return;
	// Ok - subscribe.
	list.add(topic);
    }
    
    /** Un-subscribe the specified Subscriber to the specified Topic.
     * If the subscriber has not subscribed to this topic this method
     * returns silently taking no action. 
     * @param topic The topic to stop subscribing to.
     * @param subscriber The Subscriber to remove.
     */
    public static void unsubscribe(String topic, EventSubscriber subscriber) { 
	// Ignore if no entry for event.
	if (instance.registry.get(subscriber) == null)
	    return;
	// If not already subscribed - exit.
	List list = (List)instance.registry.get(subscriber);
	if (!list.contains(topic))
	    return;
	// Ok - unsubscribe.
	list.remove(topic);
    }

    /** Remove a subscrber's subscription to all topics.*/
    public static void removeSubscriptions(EventSubscriber subscriber) {
	if (instance.registry.containsKey(subscriber)) {
	    List list = (List)instance.registry.get(subscriber);
	    list.clear();
	}
    }

    /** @return The List of Subscribers which have registered for the
     * specified topic and any topics higher in the tree. 
     * @param topic The topic to check for subscribers.
     */
    public static List findSubscribers(String topic) {
	List results = new Vector();

	EventSubscriber subscriber = null;
	List   list = null;
	String atopic = null;

	Iterator it = instance.registry.keySet().iterator();
	while (it.hasNext()) {
	    subscriber = (EventSubscriber)it.next();
	    list       = (List)instance.registry.get(subscriber);
	    Iterator topics = list.iterator();
	    boolean  found  = false;
	    while (topics.hasNext() && !found ) {
		atopic = (String)topics.next();
		if (topic.startsWith(atopic)) {
		    found = true;
		    results.add(subscriber);
		}
	    }
	}
	return results;
    }
    
    /** Remove all subscribers which have registered for the
     * specified Topic BUT NOT subtopics. 
     * Subscribers recieve no warning of this. 
     * If no subscribers have been registered this method
     * returns silently taking no action. 
     * @param topic The topic to check for subscribers.
     */
    public static void removeSubscribers(String topic) {
	
	EventSubscriber subscriber = null;
	List   list = null;
	
	Iterator it = instance.registry.keySet().iterator();
	while (it.hasNext()) {
	    subscriber = (EventSubscriber)it.next();
	    list       = (List)instance.registry.get(subscriber);
	    if (list.contains(topic))
		list.remove(topic);
	}	
    }
    
   
    /** Remove all subscribers which have registered for <b>any</b>
     * and all events. Subscribers recieve no warning of this.*/
    public static void removeAllSubscribers() {
	instance.registry.clear();
    }
    
}

/** $Log: EventRegistry.java,v $
/** Revision 1.1  2006/12/12 08:29:47  snf
/** Initial revision
/**
/** Revision 1.1  2006/05/17 06:31:45  snf
/** Initial revision
/**
/** Revision 1.1  2000/12/22 14:40:37  snf
/** Initial revision
/** */
