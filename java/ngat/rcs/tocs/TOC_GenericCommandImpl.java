/*   
    Copyright 2006, Astrophysics Research Institute, Liverpool John Moores University.

    This file is part of Robotic Control System.

     Robotic Control Systemis free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    Robotic Control System is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Robotic Control System; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */
package ngat.rcs.tocs;

import ngat.rcs.*;
import ngat.rcs.tms.*;
import ngat.rcs.emm.*;
import ngat.rcs.newstatemodel.StandardStateModel;
import ngat.rcs.ops.OperationsManager;

import java.util.*;
import java.io.*;
import java.text.*;

import ngat.net.*;
import ngat.util.*;
import ngat.util.logging.*;
import ngat.phase2.*;
import ngat.icm.DetectorArrayPosition;
import ngat.icm.InstrumentCapabilities;
import ngat.icm.InstrumentCapabilitiesProvider;
import ngat.icm.InstrumentDescriptor;
import ngat.icm.InstrumentRegistry;
import ngat.icm.InstrumentStatus;
import ngat.icm.InstrumentStatusProvider;
import ngat.astrometry.*;

/**
 * Test version of a Generic command handler for TCC commands.
 * 
 * <dl>
 * <dt><b>RCS:</b>
 * <dd>$Id: TOC_GenericCommandImpl.java,v 1.7 2008/07/10 09:54:15 eng Exp eng $
 * <dt><b>Source:</b>
 * <dd>$Source:
 * /home/dev/src/rcs/java/ngat/rcs/tocs/RCS/TOC_GenericCommandImpl.java,v $
 * </dl>
 * 
 * @author $Author: eng $
 * @version $Revision: 1.7 $
 */
public class TOC_GenericCommandImpl implements RequestHandler {

	static final String CLASS = "TOCGenericCommandImpl";

	static final long DEFAULT_HANDLING_TIME = 600000L;

	public static final long DEFAULT_HANDLING_OVERHEAD = 90000L;

	public static final long MAX_SLEW_TIME = 200000L;

	public static final long MAX_ACQUIRE_TIME = 600000L;

	public static final long MAX_STOP_TIME = 200000L;

	public static final long MAX_CONFIG_TIME = 200000L;

	public static final long MAX_FOCALPLANE_TIME = 200000L;
	
	public static final long MAX_OFFSET_TIME = 200000L;

	public static final long MAX_AG_TIME = 600000L;

	public static final long MAX_SELECT_TIME = 300000L;

	public static final long MAX_INIT_TIME = 300000L;

	public static final double DEFAULT_READOUT_TIME = 15000.0;

	// Configuration parameters temporarily set here.
	public static final double MAX_AGRADIAL_POSITION = 150.0; // mm

	public static final double FUDGE = 1.4;

	/** A logger to use for logging. */
	protected static Logger logger;

	/** The COMMAND which was received from the client. */
	protected String command;

	/** Stores the response for the client. */
	protected String reply;

	/** Object to synch on. */
	protected Object synch;

	/**
	 * The ProtocolImpl which carries out the server function for and which
	 * invoked this handler.
	 */
	protected TOC_ProtocolServerImpl serverImpl;

	/**
	 * A period at which the handler should timeout and tell the server to send
	 * an error response to the client.
	 */
	protected long handlingTime;

	/** The name of the client - via HELO <name>. */
	protected String clientName;

	/** Reference to the TOCA. */
	TOControlAgent tocAgent;

	/** The current Service. */
	TOControlAgent.ServiceDescriptor currentSA;

	/** Reference to the TAsk generated by this handler - if it did so. */
	protected Task handlerTask;

	/** The currently selected instrument. */
	protected static String selectedInstId;

	/** The current InstrumentConfig. */
	protected static IInstrumentConfig currentInstConfig;

	/** The current rot angle. */
	protected static double currentRotatorAngle;

	/** The current rot mode. */
	protected static int currentRotatorMode;

	/**
	 * Create a TOC_GenericCommandImpl replying to the specified serverImpl and
	 * processing the specified command string.
	 */
	public TOC_GenericCommandImpl(TOC_ProtocolServerImpl serverImpl, String command) {
		this.serverImpl = serverImpl;
		this.command = command;
		handlingTime = DEFAULT_HANDLING_TIME;
		if (logger == null)
			logger = LogManager.getLogger("TOCS");
	}

	public long getDefaultHandlingTime() {
		return DEFAULT_HANDLING_TIME;
	}

	public long getHandlingTime() {
		return handlingTime;
	}

	public void handleRequest() 
	{

		logger.log(1, CLASS, "-", "handleRequest", "Received TOC command: " + command);

		reply = null;

		tocAgent = (TOControlAgent) TOControlAgent.getInstance();

		StringTokenizer parser = new StringTokenizer(command);

		// Get the current service (if any).
		currentSA = tocAgent.getCurrentService();

		// Get the verb.
		String verb = parser.nextToken();

		// Only an ALERT is acceptable when TOCA is not in control.
		if (verb.equalsIgnoreCase("ALERT")) 
		{
			processALERTCommand(parser);
		}
		else if (verb.equalsIgnoreCase("HELP"))
		{
			// -------------
			// HELP Command.
			// -------------
			processHELPCommand(parser);
		} 
		else if	(verb.equalsIgnoreCase("WHEN")) 
		{
			// -------------
			// WHEN Command.
			// -------------
			processWHENCommand(parser);
		} 
		else if (verb.equalsIgnoreCase("GET_IMAGE")) 
		{
			// ------------------
			// GET_IMAGE Command.
			// ------------------
			processGETIMAGECommand(parser);
		}
		else if (verb.equalsIgnoreCase("STATUS")) 
		{
			// ---------------
			// STATUS Command. (Return status for <cat> and <key>).
			// ---------------
			processSTATUSCommand(parser);
		} 
		else if (verb.equalsIgnoreCase("POSITION"))
		{
			// ---------------
			// POSIT Command. (Position Calculations).
			// ---------------
			processPOSITIONCommand(parser);
		} 
		else if (verb.equalsIgnoreCase("SHOW")) 
		{
			// ---------------
			// SHOW Command. (Show SA info).
			// ---------------
			processSHOWCommand(parser);
		} 
		else if (verb.equalsIgnoreCase("INFO"))
		{
			// ---------------
			// INFO Command. (Assorted information).
			// ---------------
			processINFOCommand(parser);
		}
		else if (verb.equalsIgnoreCase("CHECK_OPER")) 
		{
			processCHECK_OPERCommand(parser);
		}

		// --------------------------------------
		// REJECT ACTIVE COMMANDS IF INITIALIZING
		// --------------------------------------
		if(!TOC_Server.accepting()) 
		{
			processError("TOCA_NOT_ACTIVE");

		}
		else if (verb.equalsIgnoreCase("HELO"))
		{
			// -------------
			// HELO Command. (Lets the TOC_Server identify (SA) client).
			// -------------
			processHELOCommand(parser);
		} 
		else if (verb.equalsIgnoreCase("INIT")) 
		{
			// -------------
			// INIT Command.
			// -------------
			processINITCommand(parser);
		}
		else if (verb.equalsIgnoreCase("QUIT")) 
		{
			// -------------
			// QUIT Command. (Disconnect this SA).
			// -------------
			processQUITCommand(parser);
		}
		else if (verb.equalsIgnoreCase("SLEW")) 
		{
			// -------------
			// SLEW Command. (Slew telescope to RA (hh:mm:ss.SS) Dec
			// (ddd:mm:ss.SS)).
			// -------------
			processSLEWCommand(parser);
		} 
		else if (verb.equalsIgnoreCase("OFFSET")) 
		{
			// ---------------
			// OFFSET Command. (Offset telescope from current position by d-ra sec
			// and d-dec arcsec).
			// ---------------
			processOFFSETCommand(parser);
		} 
		else if (verb.equalsIgnoreCase("INSTR")) 
		{
			// --------------
			// INSTR Command.
			// --------------
			processINSTRCommand(parser);
		} 
		else if (verb.equalsIgnoreCase("EXPOSE"))
		{
			// ---------------
			// EXPOSE Command. (Take exposure length <time> secs, <mult> runs,
			// dpflag T/F).
			// ---------------
			processEXPOSECommand(parser);
		} 
		else if (verb.equalsIgnoreCase("ACQUIRE")) 
		{
			// ---------------
			// ACQUIRE Command. (Acquire target).
			// ---------------
			processACQUIRECommand(parser);
		} 
		else if (verb.equalsIgnoreCase("STOP"))
		{
			// ---------------
			// STOP Command. (Stop all axes from tracking).
			// ---------------
			processSTOPCommand(parser);
		} 
		else if (verb.equalsIgnoreCase("AUTO")) 
		{
			// ---------------
			// AUTO Command. (Autoguide stuff).
			// ---------------
			processAUTOCommand(parser);
		}
		else if (verb.equalsIgnoreCase("AGRADIAL"))
		{
			// ---------------
			// AGRADIAL Command. (Autoguide move stuff).
			// ---------------
			processAGRADIALCommand(parser);
		} 
		else 
		{
			reply = "ERROR UNKNOWN_COMMAND " + command;
			processReply(reply);
		}
	}

	/** Process a HELP command. */
	public void processHELPCommand(StringTokenizer parser) {
		reply = "The following commands are permitted:" + "\nHELO <serviceID>   : Lets the TOC_Server identify client."
				+ "\nINIT <sessionID> <init-option>" + "\n                   : Starts initialization sequence."
				+ "\nSLEW <sessionID> <name> <ra> <dec>"
				+ "\n                   : Slew telescope to RA (hh:mm:ss.SS) Dec (ddd:mm:ss.SS)."
				+ "\nOFFSET <sessionID> <d-ra> <d-dec> "
				+ "\n                   : Offset telescope from current position by d-ra sec and d-dec arcsec."
				+ "\nINSTR <sessionID> <instID> [instrument-params]"
				+ "\n                   : Configure selected instrument. (Examples below)"
				+ "\n  e.g. IO:O <filter> <lowerslide> <upperslide> <bin> [B][A]"
				+ "\n                   : Configure IO:O using the filters and binning."
				+ "\n  e.g. RISE <bin>"
				+ "\n                   : Configure RISE using the specified binning."
				+ "\n  e.g. MOPTOP <rotorSpeed> <filter> <xbin> <ybin>"
				+ "\n                   : Configure Moptop using the specified rotor speed (slow|fast), filter and binning."
				+ "\n  e.g. LIRIC <nudgematicOffsetSize> <coaddExposureLength> <filter>"
				+ "\n                   : Configure LIRIC using the specified nudgematic offset size (small|large), coadd exposure length (100|1000), filter and binning."
				+ "\nEXPOSE <sessionID> <time> [<mult> | <at> ] <dpflag> "
				+ "\n                   : Take exposure length <time> secs, <mult> runs, dp(rt) T/F."
				+ "\nSTOP <sessionID> " + "\n                   : Stop axes tracking." + "\nQUIT <sessionID>"
				+ "\n                   : End current SA session."
				+ "\nSTATUS <cat> <key> : Various status info. E.g. instrument availablity."
				+ "\nPOSITION <ra> <dec>: Compute alt/az for specified target position.";
//				+ "\n  e.g. RATCAM <u-filter> <l-filter> <bin> [B][A}"
//				+ "\n                   : Configure the RATCam using the lower, upper filters and binning."
//				+ "\n  e.g. MEROPE <f0> <f1> [<f2>] <bin> [B][A}"
//				+ "\n                   : Configure the Merope using 2 or 3 filters and binning."
//				+ "\n  e.g. NUVSPEC <wavelength>"
//				+ "\n                   : Configure the NUVSpec using the selected wavelength"
//				+ "\n  e.g. MESSPEC <filter-slide>"
//				+ "\n                   : Configure the MESSpec with selected filter-slide position."
//				+ "\n  e.g. FRODOSPEC <red_grate> <red_wav> <blue_grate> <blue_wav> <window>"
//				+ "\n                   : Configure the FRODOSpec with assigned red and blue grating"
//				+ "\n                     selection and wavelengths plus a window size."
		processReply(reply);
	}

	/** Process an ALERT command. */
	public void processALERTCommand(StringTokenizer parser) {
		// ### TEMP fudge for now.
		EventQueue.postEvent("TO.OVERRIDE.ON");
		EventQueue.postEvent("TO.ON");

		reply = "OK Posted TO override messages to OPS_MGR";
		processReply(reply);
		return;
	}

	/** Process a GET_IMAGE command. */
	public void processGETIMAGECommand(StringTokenizer parser) {
		// GET_IMAGE <imagefile> <destfile> <sendtohost> <sendtoport>
		if (parser.countTokens() < 4) {
			processError("MISSING_PARAMETERS", "Use: GET_IMAGE <send-file> <dest-file> <dest-host> <dest-port>");
			return;
		}

		String sendFileName = parser.nextToken();
		File sendFile = new File(sendFileName);
		if (!sendFile.exists()) {
			processError("FILETRANSFER", "File: " + sendFileName + " does not exist");
			return;
		}

		String destFileName = parser.nextToken();

		String host = parser.nextToken();
		String strPort = parser.nextToken();
		int port = 0;
		try {
			port = Integer.parseInt(strPort);
		} catch (Exception px) {
			processError("FILETRANSFER", "Cannot determine port: " + strPort);
			return;
		}

		try {
			SSLFileTransfer.Client client = new SSLFileTransfer.Client("TOFS_PUSH", host, port, false);
			client.setBandWidth(5); // 5
			client.setBufferLength(2048); // 1024
			client.send(sendFileName, destFileName);
		} catch (Exception e) {
			e.printStackTrace();
			processError("FILE_TRANSFER", "Exception: " + e);
		}

		reply = "OK sent";
		processReply(reply);

	}

	/** Process a POSITION command. */
	public void processPOSITIONCommand(StringTokenizer parser) {

		if (parser.countTokens() < 2) {
			processError("MISSING_PARAMETERS", "Use: POSITION <ra> <dec>");
			return;
		}

		String strRa = parser.nextToken();
		double ra = 0.0;
		try {
			ra = Position.parseHMS(strRa);
		} catch (ParseException px) {
			processError("RA_FORMAT", "Use format: HH:MM:SS.ss");
			return;
		}

		String strDec = parser.nextToken();
		double dec = 0.0;
		try {
			dec = Position.parseDMS(strDec);
		} catch (ParseException px) {
			processError("DEC_FORMAT", "Use format: [+/-]DD:MM:SS.ss");
			return;
		}

		if (ra < 0.0 || ra > (2.0 * Math.PI)) {
			processError("RA", "Out of range: (0, 24H)");
			return;
		}

		if (dec < -Math.PI / 2.0 || dec > Math.PI / 2.0) {
			processError("DEC", "Out of range: (-90, +90)");
			return;
		}

		Position target = new Position(ra, dec);

		String cat = "";
		String state = "";
		long tts = 0L;
		long ttr = 0L;
		double az = 0.0;
		double alt = 0.0;
		double ld = 0.0;

		double lim = RCS_Controller.getDomelimit();

		if (target.neverRises(lim)) {
			cat = "NEVER_RISES";

			// Set dodgy-defaults for all params.
			state = "SET";
			tts = 0L;
			ttr = -1L;

		} else {

			if (target.neverSets(lim)) {
				cat = "NEVER_SETS";
				state = "RISEN";
				tts = -1L;
				ttr = 0L;
			} else {
				cat = "RISER";

				// Calc values.

				if (target.isRisen(lim)) {
					state = "RISEN";
					tts = (long) (target.getUpTimeMillis(lim) / 1000.0);
					ttr = 0L;
				} else {
					state = "SET";
					tts = 0L;
					ttr = (long) (target.getDownTimeMillis(lim) / 1000.0);

					// do a forward sim to test that result...
					long st = System.currentTimeMillis();
					long sst = st;
					long ttr2 = 0L;
					while (sst < (st + 24 * 3600 * 100L)) {
						double alt2 = target.getAltitude(sst);
						if (alt2 > lim) {
							ttr2 = sst;
							break;
						}
						sst += 60 * 1000L; // step 1 minute
					}
					ttr2 = ttr2 - st;
					// logit

					System.err.println("TOC: Position: ttr = " + ttr + " sim ttr2=" + ttr2);

				}
			}

		}

		alt = target.getAltitude();
		az = target.getAzimuth();

		Position moon = Astrometry.getLunarPosition();
		ld = target.getAngularDistance(moon);

		reply = "OK " + " alt=" + Position.toDegrees(alt, 3) + ", az=" + Position.toDegrees(az, 3) + ", cat=" + cat
				+ ", state=" + state + ", set=" + tts + ", rise=" + ttr + ", moon=" + Position.toDegrees(ld, 3);

		processReply(reply);

	}

	/** Process an INFO command. */
	public void processINFOCommand(StringTokenizer parser) {

		if (parser.countTokens() < 1) {
			processError("MISSING_PARAMETERS", "Use: INFO <options>");
			return;
		}

		String option = parser.nextToken();

		if (option.equalsIgnoreCase("SUNSET")) {

			// Work out when (next) sunset will be.
			long now = System.currentTimeMillis();
			long sunset = RCS_Controller.getObsDate().getSunset();
			if (sunset < now)
				sunset += 24 * 3600 * 1000L;
			long ttsunset = sunset - now;

			reply = "OK sunset=" + ttsunset;

		} else if (option.equalsIgnoreCase("SUNRISE")) {

			// Work out when (next) sunrise will be.
			long now = System.currentTimeMillis();
			long sunrise = RCS_Controller.getObsDate().getSunrise();
			if (sunrise < now)
				sunrise += 24 * 3600 * 1000L;
			long ttsunrise = sunrise - now;

			reply = "OK sunrise=" + ttsunrise;

		} else {
			processError("UNKNOWN_OPTION", option);
			return;
		}

		processReply(reply);

	}

	/** Process a SHOW command. */
	public void processSHOWCommand(StringTokenizer parser) {

		if (parser.countTokens() < 1) {
			processError("MISSING_PARAMETERS", "Use: SHOW <serviceID>");
			return;
		}

		clientName = parser.nextToken();
		if (!tocAgent.isAuthorized(clientName)) {
			processError("NO_SUCH_CLIENT", clientName);
			return;
		}

		// Grab the service descriptor and check its ok.
		TOControlAgent.ServiceDescriptor theSA = tocAgent.getService(clientName);

		if (theSA == null) {
			processError("NO_SERVICE_DESCRIPTOR", clientName);
			return;
		}

		reply = "OK SA=" + theSA.toString();
		processReply(reply);

	}

	/**
	 * Process a WHEN command.
	 **/
	public void processWHENCommand(StringTokenizer parser) {

		if (parser.countTokens() < 1) {
			processError("MISSING_PARAMETERS", "Who are you?");
			return;
		}

		// Check for authorization with TOCA.
		clientName = parser.nextToken();
		if (!tocAgent.isAuthorized(clientName)) {
			processError("NOT_AUTHORIZED", clientName);
			return;
		}

		// Grab the service descriptor and check its ok.
		TOControlAgent.ServiceDescriptor thisSA = tocAgent.getService(clientName);

		if (thisSA == null) {
			processError("NO_SERVICE_DESCRIPTOR", clientName);
			return;
		}

		// Has the client got any time allocation left.
		if (thisSA.timeRemaining < 0L) {
			processError("OUT_OF_TIME", clientName + " only " + (thisSA.timeRemaining / 60000L) + " mins remaining");
			return;
		}

		// Is the RCS actually in an operational state at this time.
		if (!RCS_Controller.controller.isOperational()) {
			processError("NOT_OPERATIONAL");
			return;
		}

		// Is the TOCA currently running another higher priority SA.
		// NOTE: highest priority is ZERO.
		TOControlAgent.ServiceDescriptor currentSA = tocAgent.getCurrentService();
		if (currentSA != null && currentSA.priority < thisSA.priority) {
			long timeLeft = currentSA.sessionStartTime + currentSA.sessionAllocation - System.currentTimeMillis();
			reply = "OK Time=" + (timeLeft / 1000L) + ", Current=" + currentSA.id;
			processReply(reply);
			return;
		}

		// Looks like no higher priority SA is in control so now...
		reply = "OK Time=0, Current=" + (currentSA == null ? "NOBODY" : currentSA.id);
		processReply(reply);
	}

	/** Process a HELO command. */
	public void processHELOCommand(StringTokenizer parser) {

		if (parser.countTokens() < 1) {
			processError("MISSING_PARAMETERS", "Who are you?");
			return;
		}

		// Check for authorization with TOCA.
		clientName = parser.nextToken();
		if (!tocAgent.isAuthorized(clientName)) {
			processError("NOT_AUTHORIZED", clientName);
			return;
		}

		// Grab the service descriptor and check its ok.
		TOControlAgent.ServiceDescriptor thisSA = tocAgent.getService(clientName);

		if (thisSA == null) {
			processError("NO_SERVICE_DESCRIPTOR", clientName);
			return;
		}

		// Has the client got any time allocation left.
		if (thisSA.timeRemaining < 0L) {
			processError("OUT_OF_TIME", clientName + " only " + (thisSA.timeRemaining / 60000L) + " mins remaining");
			return;
		}

		// Is the TOCA currently running another higher priority SA.
		// NOTE: highest priority is ZERO.
		TOControlAgent.ServiceDescriptor currentSA = tocAgent.getCurrentService();
		if (currentSA != null && currentSA.priority < thisSA.priority) {
			processError("PRIORITY_OVERRIDE", "Another Service (" + currentSA.id + " : " + currentSA.priority
					+ ") is in control");
			return;
		}

		// Is the RCS actually in an operational state at this time.
		if (!RCS_Controller.controller.isOperational()) {
			processError("NOT_OPERATIONAL");
			return;
		}

		// OK, passed all the tests, try to attach.
		// If this succeeds then the SA can start sending commands.
		// There is really no reason why this should fail ?
		// Note that another (lower-priority) SA may have to be killed first.
		// TOCA needs ref to this handler to send the reply - it is NOT instant
		// as it may have to go through an abort before we start.
		if (!tocAgent.replaceService(clientName, this)) {
			processError("REJECTED", "The TOCA could not start this service at the present time");
			return;
		}

	}

	/**
	 * Process an INIT command. Will need to manage the following tasks:
	 * <ul>
	 * <li>Rotator (mode and offset).
	 * <li>AGSelect, AGMove.
	 * </ul>
	 */
	public void processINITCommand(StringTokenizer parser) {

		if (parser.countTokens() < 4) {
			processError("MISSING_PARAMETERS", "Use: INIT <sessionID> <rot-option> <focus-option> <ag-option>..");
			return;
		}

		if (!checkSession(parser))
			return;

		int nopt = parser.countTokens(); // we may have multiple options later

		String rotOption = parser.nextToken();
		int rotMode = 0;
		if (rotOption.equals("ROT_SKY"))
			rotMode = TOCInitTask.ROT_SKY;
		else if (rotOption.equals("ROT_MOUNT"))
			rotMode = TOCInitTask.ROT_MOUNT;

		else if (rotOption.equals("ROT_FLOAT"))
			rotMode = TOCInitTask.ROT_FLOAT;
		else
			processError("UNKNOWN_OPTION", "Illegal Rotator Option: " + rotOption);

		String focOption = parser.nextToken();
		int focusMode = 0;
		if (focOption.equals("FOCUS_OFF"))
			focusMode = TOCInitTask.FOCUS_OFF;
		else if (focOption.equals("FOCUS_ON"))
			focusMode = TOCInitTask.FOCUS_ON;
		else
			processError("UNKNOWN_OPTION", "Illegal Focus Option: " + focOption);

		String agOption = parser.nextToken();
		int agMode = 0;
		if (agOption.equals("AG_SELECT"))
			agMode = TOCInitTask.AG_SELECT;
		else if (agOption.equals("AG_NO_SELECT"))
			agMode = TOCInitTask.AG_NO_SELECT;
		else
			processError("UNKNOWN_OPTION", "Illegal A/G Option: " + agOption);

		TOCInitTask tinit = new TOCInitTask(tocAgent.getName() + "/TOCInit", tocAgent, this, rotMode, focusMode, agMode);

		if (!tocAgent.addNextJob(tinit)) {
			processError("QUEUE_OVERFLOW", "Too many requests queued - try again later.");
		} else {
			handlerTask = tinit;
			handlingTime = DEFAULT_HANDLING_OVERHEAD + MAX_INIT_TIME;
		}

	}

	/**
	 * Process a STOP command. Will need to manage the following tasks:
	 * <ul>
	 * <li>Track (AZ, OFF).
	 * <li>Track (ALT, OFF).
	 * <li>Track (ROT, OFF).
	 * </ul>
	 */
	public void processSTOPCommand(StringTokenizer parser) {

		if (!checkSession(parser))
			return;

		TOCStopTask tstop = new TOCStopTask(tocAgent.getName() + "/TOCStopAxes", tocAgent, this);

		if (!tocAgent.addNextJob(tstop)) {
			processError("QUEUE_OVERFLOW", "Too many requests queued - try again later.");
		} else {
			handlerTask = tstop;
			handlingTime = DEFAULT_HANDLING_OVERHEAD + MAX_STOP_TIME;
		}

	}

	/** Process a QUIT command. */
	public void processQUITCommand(StringTokenizer parser) {
		if (!checkSession(parser))
			return;

		tocAgent.killCurrentService();

		reply = "OK Service terminated.";
		processReply(reply);
	}

	/** Process an EXPOSE command. */
	public void processEXPOSECommand(StringTokenizer parser) {

		if (parser.countTokens() < 4) {
			processError("MISSING_PARAMETERS", "Use: EXPOSE <sessionID> <time> <runs> <dpflag>");
			return;
		}

		if (!checkSession(parser))
			return;

		// ## We dont allow fixed time for now ##

		String stime = parser.nextToken();
		String srun = parser.nextToken();
		String sdpflag = parser.nextToken();

		boolean dpflag = true;
		double expose = 0.0;
		int runs = 0;

		double readout = DEFAULT_READOUT_TIME;

		try {
			expose = Double.parseDouble(stime);
		} catch (NumberFormatException nx) {
			processError("EXPOSURE", "Parse: " + nx);
			return;
		}

		try {
			runs = Integer.parseInt(srun);
		} catch (NumberFormatException nx) {
			processError("MULTRUNS", "Parse: " + nx);
			return;
		}

		if (sdpflag.equals("T"))
			dpflag = true;
		else
			dpflag = false;

		// We dont actually 'need' an InstConfig for this as it should already
		// be set.
		// Maybe we should retain a previous IC which worked and set it - this
		// info
		// IS needed for the ExposureTask to work out which instrument it is
		// going for..
		if (currentInstConfig == null) {
			processError("NO_CURRENT_INSTRUMENT");
			return;
		}

		// ### We will probably need to put an ngat.phase2.Exposure object or
		// subclass
		// in here in future. We also need to know which instrument we are
		// using.
		// for now we assume its the RATCAM ...The Exposure should be able to
		// indicate which Instrument it is going for hence no need for the IC
		// here..

		TOCExposeTask texp = new TOCExposeTask(tocAgent.getName() + "/TOCExpose", tocAgent, this, runs, (float) expose,
				dpflag, currentInstConfig.getInstrumentName());

		if (!tocAgent.addNextJob(texp)) {
			processError("QUEUE_OVERFLOW", "Too many requests queued - try again later.");
		} else {
			handlerTask = texp;
			handlingTime = DEFAULT_HANDLING_OVERHEAD + (long) ((expose + readout) * runs);
		}
	}

	/** Process ACQUIRE command. */
	public void processACQUIRECommand(StringTokenizer parser) {

		if (parser.countTokens() < 4) {
			processError("MISSING_PARAMETERS", "Use: ACQUIRE <sessionID> <ra> <dec> <mode>");
			return;
		}

		if (!checkSession(parser))
			return;
		String strRA = parser.nextToken();
		String strDec = parser.nextToken();
		double ra = 0.0;
		try {
			ra = Position.parseHMS(strRA);
		} catch (ParseException px) {
			processError("RA_FORMAT", "Exception: " + px);
			return;
		}
		double dec = 0.0;
		try {
			dec = Position.parseDMS(strDec);
		} catch (ParseException px) {
			processError("DEC_FORMAT", "Exception: " + px);
			return;
		}

		String strMode = parser.nextToken();
		int acqMode = TelescopeConfig.ACQUIRE_MODE_NONE;

		if (strMode.equals("WCS"))
			acqMode = TelescopeConfig.ACQUIRE_MODE_WCS;
		else if (strMode.equals("BRIGHTEST"))
			acqMode = TelescopeConfig.ACQUIRE_MODE_BRIGHTEST;
		else {
			processError("ILLEGAL_ACQUISITION_MODE", strMode);
			return;
		}

		// do we have a current instrument?
		// Instrument currInst = null;
		if (selectedInstId == null) {
			processError("NO_CURRENT_INSTRUMENT");
			return;
		}

		InstrumentCapabilities icap = null;
		try {
			InstrumentDescriptor iid = new InstrumentDescriptor(selectedInstId);
			InstrumentRegistry ireg = RCS_Controller.controller.getInstrumentRegistry();
			InstrumentCapabilitiesProvider icp = ireg.getCapabilitiesProvider(iid);
			icap = icp.getCapabilities();
			// currInst = Instruments.findInstrument(selectedInstId);
		} catch (Exception e) {
			e.printStackTrace();
			processError("NO_CURRENT_INSTRUMENT");
			return;
		}
		/*
		 * if (currInst == null) { processError("NO_CURRENT_INSTRUMENT");
		 * return; }
		 */

		// Work out the acquisition parameters here
		String acqInstId = "RATCAM";
		/*
		 * if (acqInstId == null) {
		 * processError("NO_VALID_ACQUISTION_INSTRUMENT", selectedInstId);
		 * return; }
		 */
		
		// TODO we need to assume some specified ACQ instrument or pick in precedence order
		// then 
		
		
		int ax = 0;
		int ay = 0;		
		double acquisitionThreshold;
		
		try {
			InstrumentDescriptor instrumentDescriptor = new InstrumentDescriptor("RATCAM");
			DetectorArrayPosition dap = icap.getAcquisitionTargetPosition(instrumentDescriptor);
			ax = (int) dap.getDetectorArrayPositionX();
			ay = (int) dap.getDetectorArrayPositionY();
			acquisitionThreshold = icap.getAcquisitionThreshold(instrumentDescriptor, false);
		} catch (Exception e) {
			e.printStackTrace();
			processError("ILLEGAL_ACQUIRE_INSTRUMENT");
			return;
		}
		
		
		TOCAcquireTask tacq = new TOCAcquireTask(tocAgent.getName() + "/TOCAcquire", tocAgent, this, ra, dec,
				acqInstId, ax, ay, acquisitionThreshold, acqMode);

		if (!tocAgent.addNextJob(tacq)) {
			processError("QUEUE_OVERFLOW", "Too many requests queued - try again later.");
		} else {
			handlerTask = tacq;
			handlingTime = DEFAULT_HANDLING_OVERHEAD + MAX_ACQUIRE_TIME;
		}

	}

	/** Process a SLEW command. */
	public void processSLEWCommand(StringTokenizer parser) {
		// ##### Watchout - we need to do substitution for quoted id here - very
		// messy.

		if (parser.countTokens() < 4) {
			processError("MISSING_PARAMETERS", "Use: SLEW <sessionID> <srcId> <ra> <dec>");
			return;
		}

		if (!checkSession(parser))
			return;

		String srcName = parser.nextToken();
		String srcRA = parser.nextToken();
		String srcDec = parser.nextToken();
		double ra = 0.0;
		double dec = 0.0;
		ExtraSolarSource source = new ExtraSolarSource(srcName);
		try {
			// We expect to use ':' as delimiter.
			ra = Position.parseHMS(srcRA);
			source.setRA(ra);
		} catch (ParseException px) {
			processError("RA_FORMAT", "Exception: " + px);
			return;
		}
		try {
			dec = Position.parseDMS(srcDec);
			source.setDec(dec);
		} catch (ParseException px) {
			processError("DEC_FORMAT", "Exception: " + px);
			return;
		}

		double domeLimit = RCS_Controller.getDomelimit();
		Position target = new Position(ra, dec);
		double alt = target.getAltitude();
		if (alt < domeLimit) {
			processError("TARGET_SET", "Elevation: " + Position.toDegrees(alt, 2) + ", Limit: "
					+ Position.toDegrees(domeLimit, 2));
			return;
		}

		source.setPmRA(0.0);
		source.setPmDec(0.0);
		source.setParallax(0.0);
		source.setRadialVelocity(0.0);
		source.setEpoch(2000.0F);
		source.setEquinox(2000.0F);
		source.setEquinoxLetter('J');
		source.setFrame(Source.FK5);

		TOCSlewTask tslew = new TOCSlewTask(tocAgent.getName() + "/TOCSlew", tocAgent, this, source);

		if (!tocAgent.addNextJob(tslew)) {
			processError("QUEUE_OVERFLOW", "Too many requests queued - try again later.");
		} else {
			handlerTask = tslew;
			handlingTime = DEFAULT_HANDLING_OVERHEAD + MAX_SLEW_TIME;
		}
	}

	/** Process an AUTO command. */
	public void processAUTOCommand(StringTokenizer parser) {

		if (parser.countTokens() < 2) {
			processError("MISSING_PARAMETERS", "Use: AUTO <sessionID> < ON | OFF >");
			return;
		}

		if (!checkSession(parser))
			return;

		String state = parser.nextToken();

		if (state.equals("ON")) {

			TOCAutoguideTask tauto = new TOCAutoguideTask(tocAgent.getName() + "/TOCAutoON", tocAgent, this, true);

			if (!tocAgent.addNextJob(tauto)) {
				processError("QUEUE_OVERFLOW", "Too many requests queued - try again later.");
			} else {
				handlerTask = tauto;
				handlingTime = DEFAULT_HANDLING_OVERHEAD + MAX_AG_TIME;
			}

		} else if (state.equals("OFF")) {

			TOCAutoguideTask tauto = new TOCAutoguideTask(tocAgent.getName() + "/TOCAutoOFF", tocAgent, this, false);

			if (!tocAgent.addNextJob(tauto)) {
				processError("QUEUE_OVERFLOW", "Too many requests queued - try again later.");
			} else {
				handlerTask = tauto;
				handlingTime = DEFAULT_HANDLING_OVERHEAD + MAX_AG_TIME;
			}

		} else {
			processError("AG_STATE", "Use: ON / OFF");
			return;
		}
	}

	/** Process an OFFSET command. */
	public void processOFFSETCommand(StringTokenizer parser) {

		if (parser.countTokens() < 3) {
			processError("MISSING_PARAMETERS", "Use: OFFSET <sessionID> <dra> <ddec>");
			return;
		}

		if (!checkSession(parser))
			return;

		String sdra = parser.nextToken(); // arc-sec.
		String sddec = parser.nextToken(); // arc-sec.

		double dra = 0.0;
		double ddec = 0.0;

		try {
			dra = Math.toRadians(Double.parseDouble(sdra) / 3600.0);
		} catch (NumberFormatException nx) {
			reply = "ERROR DELTA_RA " + nx;
			processReply(reply);
		}

		try {
			ddec = Math.toRadians(Double.parseDouble(sddec) / 3600.0);
		} catch (NumberFormatException nx) {
			reply = "ERROR DELTA_DEC " + nx;
			processReply(reply);
		}

		TOCOffsetTask toff = new TOCOffsetTask(tocAgent.getName() + "/TOCOffset", tocAgent, this, dra, ddec);

		if (!tocAgent.addNextJob(toff)) {
			processError("QUEUE_OVERFLOW", "Too many requests queued - try again later.");
		} else {
			handlerTask = toff;
			handlingTime = DEFAULT_HANDLING_OVERHEAD + MAX_OFFSET_TIME;
		}
	}

	/** Process an AGRADIAL command. */
	public void processAGRADIALCommand(StringTokenizer parser) {

		if (parser.countTokens() < 2) {
			processError("MISSING_PARAMETERS Use: AGRADIAL <sessionID> <position>");
			return;
		}

		if (!checkSession(parser))
			return;

		String spos = parser.nextToken(); // mm

		double pos = 0.0;

		try {
			pos = Double.parseDouble(spos);
		} catch (NumberFormatException nx) {
			reply = "ERROR POSITION Badly formatted - " + nx;
			processReply(reply);
		}

		if (pos < 0 || pos > MAX_AGRADIAL_POSITION) {
			processError("POSITION " + pos + " outside range [0 - " + MAX_AGRADIAL_POSITION + "]");
			return;
		}

		TOCAgRadialTask tagrad = new TOCAgRadialTask(tocAgent.getName() + "/TOCAgRadial", tocAgent, this, pos);

		if (!tocAgent.addNextJob(tagrad)) {
			processError("QUEUE_OVERFLOW", "Too many requests queued - try again later.");
		} else {
			handlerTask = tagrad;
			handlingTime = DEFAULT_HANDLING_OVERHEAD + MAX_OFFSET_TIME;
		}
	}
	
	/**
	 * Process a FOCALPLANE command.
	 * @param parser An instance of StringTokenizer containing the FOCALPLANE command parameters,
	 *               tokenised by spaces.
	 * @see #tocAgent
	 * @see #checkSession
	 */
	public void processFOCALPLANECommand(StringTokenizer parser) 
	{
		// We expect at least the instrument id.

		if (parser.countTokens() < 2) {
			reply = "ERROR FOCALPLANE No instrument specified";
			processReply(reply);
			return;
		}
		if (!checkSession(parser))
			return;
		String instumentName = parser.nextToken();
		
		TOCFocalPlaneTask focalPlaneTask = new TOCFocalPlaneTask(tocAgent.getName() + "/TOCFocalPlane",
				tocAgent, this,instumentName);
		if (!tocAgent.addNextJob(focalPlaneTask)) 
		{
			processError("QUEUE_OVERFLOW", "Too many requests queued - try again later.");			
		} 
		else 
		{
			handlerTask = focalPlaneTask;
			handlingTime = DEFAULT_HANDLING_OVERHEAD + MAX_FOCALPLANE_TIME;
		}
		
	}
	
	/**
	 * Process an INSTR command. This parses the INSTR command parameters and constructs a TOCInstrumentTask
	 * task that is added to the tocAgent queue.
	 * <ul>
	 * <li>We check we have at least an instrument name specified.
	 * <li>We call checkSession.
	 * <li>We parse the first token as the instrument name.
	 * <li>We construct a specific instance of an object that supports the IInstrumentConfig interface,
	 *     based on the instrument name.
	 * <li>We check we have successfully managed to construct an instConfig (supporting the IInstrumentConfig interface).
	 * <li>We get the instrument status provider from the instrument registry for the specified instrument.
	 * <li>We check the instrument isOnline and isFunctional from the instrument status.
	 * <li>We construct an instance of the TOCInstrumentTask and add it to the tocAgent.
	 * <li>We update the selectedInstId and currentInstConfig.
	 * </ul>
	 * The following INSTR command syntaxes are supported:
	 * <ul>
	 * <li>RATCAM <lf> <uf> <bin> [B][A]
	 * <li>IO:O <filter> <lowerslide> <upperslide> <bin>
	 * <li>IO:THOR <emgain> <bin> <xs> <xe> <ys> <ye>
	 * <li>RISE <bin> [B][A]
	 * <li>RINGO3 <trig> <emgain> <xbin> <ybin> [B][A]
	 * <li>RINGO2 <trig> <emgain> <xbin> <ybin> [B][A]
	 * <li>MOPTOP <rotorSpeed> <filter> <xbin> <ybin>
	 * <li>LIRIC <nudgematicOffsetSize> <coaddExposureLength> <filter>
	 * <li>SPRAT <slit:in|out> <grism:in|out> <grism:red|blue>
	 * </ul>
	 * @param parser An instance of StringTokenizer containing the INSTR command parameters, tokenised by spaces.
	 * @see #tocAgent
	 * @see #checkSession
	 * @see #selectedInstId
	 * @see #currentInstConfig
	 * @see #handlerTask
	 * @see #handlingTime
	 */
	public void processINSTRCommand(StringTokenizer parser) {
		// We expect at least the instrument id.

		if (parser.countTokens() < 2) {
			reply = "ERROR INSTRUMENT No instrument specified";
			processReply(reply);
			return;
		}

		if (!checkSession(parser))
			return;
		String instId = parser.nextToken();

		IInstrumentConfig instConfig = null;

		// ------------
		// RAT Command. (Configure the RATCam using the lower, upper filters and
		// binning).
		// ------------
		if (instId.startsWith("RATCAM")) 
		{
			// RATCAM <lf> <uf> <bin> [B][A]

			if (parser.countTokens() < 3) 
			{
				reply = "ERROR MISSING_PARAMETERS Use: INSTR <session> RATCAM <l-filter> <u-filter> <bin>";
				processReply(reply);
				return;
			}

			String lowerFilter = parser.nextToken();
			String upperFilter = parser.nextToken();
			String sbins = parser.nextToken();

			XImagerInstrumentConfig ccdConfig = new XImagerInstrumentConfig("TOC_RATCam");
			ccdConfig.setInstrumentName("RATCAM");
			XFilterSpec filters = new XFilterSpec();
			filters.addFilter(new XFilterDef(lowerFilter));
			filters.addFilter(new XFilterDef(upperFilter));
			ccdConfig.setFilterSpec(filters);
			try 
			{
				int xyBins = Integer.parseInt(sbins);
				XDetectorConfig detector = new XDetectorConfig();
				detector.setXBin(xyBins);
				detector.setYBin(xyBins);
				ccdConfig.setDetectorConfig(detector);
			} 
			catch (NumberFormatException nx) 
			{
				reply = "ERROR BINNING " + nx;
				processReply(reply);
				return;
			}

			instConfig = ccdConfig;

			
		} 
		else if(instId.equalsIgnoreCase("IO:O")) 
		{
			
			// IO:O

			if (parser.countTokens() < 3) 
			{
				reply = "ERROR MISSING_PARAMETERS Use: INSTR <session> IO:O <filter> <lowerslide> <upperslide> <bin>";
				processReply(reply);
				return;
			}

			String filter = parser.nextToken();		
			String lowerNDFilter = parser.nextToken();		
			String upperNDFilter = parser.nextToken();		
			String sbins = parser.nextToken();

			XImagerInstrumentConfig oConfig = new XImagerInstrumentConfig("TOC_IO:O");
			oConfig.setInstrumentName("IO:O");
			XFilterSpec filters = new XFilterSpec();
			filters.addFilter(new XFilterDef(filter));		
			filters.addFilter(new XFilterDef(lowerNDFilter));
			filters.addFilter(new XFilterDef(upperNDFilter));
			
			oConfig.setFilterSpec(filters);
			try 
			{
				int xyBins = Integer.parseInt(sbins);
				XDetectorConfig detector = new XDetectorConfig();
				detector.setXBin(xyBins);
				detector.setYBin(xyBins);
				oConfig.setDetectorConfig(detector);
			} 
			catch (NumberFormatException nx) 
			{
				reply = "ERROR BINNING " + nx;
				processReply(reply);
				return;
			}

			instConfig = oConfig;			
			
		} 
		else if (instId.equalsIgnoreCase("IO:THOR")) 
		{
			
			
			if (parser.countTokens() < 6) 
			{
				reply = "ERROR MISSING_PARAMETERS Use: INSTR <session> IO:THOR <emgain> <bin> <xs> <xe> <ys> <ye>";
				processReply(reply);
				return;
			}
		
			String strgain = parser.nextToken();
			String sbins = parser.nextToken();

			XTipTiltImagerInstrumentConfig thorConfig = new XTipTiltImagerInstrumentConfig("TOC_IO:THOR");
			thorConfig.setInstrumentName("IO:THOR");
			
			int gain = 1;		
			try 
			{
				gain = Integer.parseInt(strgain);
			} 
			catch (NumberFormatException nx) 
			{
				reply = "ERROR GAIN: " + nx;
				processReply(reply);
				return;
			}
			if (gain < 0 || gain > 100) 
			{
				reply = "ERROR GAIN: (1 <= gain <= 100)";
				processReply(reply);
				return;
			}
			thorConfig.setGain(gain);
			
			XDetectorConfig detector = null;
			try 
			{
				int xyBins = Integer.parseInt(sbins);
				detector = new XDetectorConfig();
				detector.setXBin(xyBins);
				detector.setYBin(xyBins);
				thorConfig.setDetectorConfig(detector);
				XFilterSpec filters = new XFilterSpec();			
				thorConfig.setFilterSpec(filters);
			} 
			catch (NumberFormatException nx) 
			{
				reply = "ERROR BINNING " + nx;
				processReply(reply);
				return;
			}
			
			// xs,xe,ys,ye
			String strXs = parser.nextToken();
			String strXe = parser.nextToken();
			String strYs = parser.nextToken();
			String strYe = parser.nextToken();
			try 
			{
				int xs = Integer.parseInt(strXs);
				int xe = Integer.parseInt(strXe);
				int ys = Integer.parseInt(strYs);
				int ye = Integer.parseInt(strYe);
				
				// should check the windows make sense here
				
				XWindow window = new XWindow(xs, ys, xe-xs, ye-ys);
				detector.addWindow(window);
		
			} 
			catch (Exception wx) 
			{
				reply = "ERROR WINDOW " + wx;
				processReply(reply);
			}
			
			instConfig = thorConfig;	
			
		} 
		else if (instId.startsWith("RISE")) 
		{
						
			// RISE <bin> [B][A]

			if (parser.countTokens() < 1) 
			{
				reply = "ERROR MISSING_PARAMETERS Use: INSTR <session> RISE <bin> }";
				processReply(reply);
				return;
			}

			String sbins = parser.nextToken();

			XImagerInstrumentConfig riseConfig = new XImagerInstrumentConfig("TOC_RISE");
			riseConfig.setInstrumentName("RISE");

			try 
			{
				int xyBins = Integer.parseInt(sbins);
				XDetectorConfig detector = new XDetectorConfig();
				detector.setXBin(xyBins);
				detector.setYBin(xyBins);
				riseConfig.setDetectorConfig(detector);
			} 
			catch (NumberFormatException nx) 
			{
				reply = "ERROR BINNING " + nx;
				processReply(reply);
				return;
			}

			instConfig = riseConfig;

		} 
		else if (instId.equals("RINGO3")) 
		{
			
			// RINGO3 <trig> <emgain> <xbin> <ybin> [B][A]

			if (parser.countTokens() < 4) 
			{
				reply = "ERROR MISSING_PARAMETERS Use: INSTR <session> RINGO3 <trig> <emgain> <xbin> <ybin> }";
				processReply(reply);
				return;
			}

			XPolarimeterInstrumentConfig polConfig = new XPolarimeterInstrumentConfig("TOC_RINGO3");
			polConfig.setInstrumentName("RINGO3");
			String strtrig = parser.nextToken(); // ignore tigger type

			int gain = 1;
			String strgain = parser.nextToken();
			try 
			{
				gain = Integer.parseInt(strgain);
			} 
			catch (NumberFormatException nx) 
			{
				reply = "ERROR GAIN: " + nx;
				processReply(reply);
				return;
			}
			if (gain < 0 || gain > 100) 
			{
				reply = "ERROR GAIN: (1 <= gain <= 100)";
				processReply(reply);
				return;
			}
			polConfig.setGain(gain);

			String sxbin = parser.nextToken();
			String sybin = parser.nextToken();

			try 
			{
				XDetectorConfig detector = new XDetectorConfig();
				int xBins = Integer.parseInt(sxbin);
				detector.setXBin(xBins);
				int yBins = Integer.parseInt(sybin);
				detector.setYBin(yBins);
				polConfig.setDetectorConfig(detector);
			} 
			catch (NumberFormatException nx) 
			{
				reply = "ERROR BINNING " + nx;
				processReply(reply);
				return;
			}

			instConfig = polConfig;
			
			
		} 
		else if (instId.equals("RINGO2")) 
		{


			// RINGO2 <trig> <emgain> <xbin> <ybin> [B][A]

			if (parser.countTokens() < 4) 
			{
				reply = "ERROR MISSING_PARAMETERS Use: INSTR <session> RINGO2 <trig> <emgain> <xbin> <ybin>";
				processReply(reply);
				return;
			}

			XPolarimeterInstrumentConfig polConfig = new XPolarimeterInstrumentConfig("TOC_RINGO2");
			polConfig.setInstrumentName("RINGO2");
			String strtrig = parser.nextToken(); // ignore tigger type

			int gain = 1;
			String strgain = parser.nextToken();
			try 
			{
				gain = Integer.parseInt(strgain);
			} 
			catch (NumberFormatException nx) 
			{
				reply = "ERROR GAIN: " + nx;
				processReply(reply);
				return;
			}
			if (gain < 0 || gain > 100) 
			{
				reply = "ERROR GAIN: (1 <= gain <= 100)";
				processReply(reply);
				return;
			}
			polConfig.setGain(gain);

			String sxbin = parser.nextToken();
			String sybin = parser.nextToken();

			try 
			{
				XDetectorConfig detector = new XDetectorConfig();
				int xBins = Integer.parseInt(sxbin);
				detector.setXBin(xBins);
				int yBins = Integer.parseInt(sybin);
				detector.setYBin(yBins);
				polConfig.setDetectorConfig(detector);
			} 
			catch (NumberFormatException nx) 
			{
				reply = "ERROR BINNING " + nx;
				processReply(reply);
				return;
			}

			instConfig = polConfig;

		} 
		else if (instId.equals("MOPTOP")) 
		{
			
			// MOPTOP <rotorSpeed> <filter> <xbin> <ybin>

			if (parser.countTokens() < 4) 
			{
				reply = "ERROR MISSING_PARAMETERS Use: INSTR <session> MOPTOP <rotorSpeed> <filter> <xbin> <ybin>";
				processReply(reply);
				return;
			}
			// construct config
			XMoptopInstrumentConfig moptopConfig = new XMoptopInstrumentConfig("TOC_MOPTOP");
			moptopConfig.setInstrumentName("MOPTOP");

			// parse command parameters
			String rotorSpeedString = parser.nextToken(); 
			String filterString = parser.nextToken();
			String xBinString = parser.nextToken();
			String yBinString = parser.nextToken();

			// rotor speed
			if(rotorSpeedString.equalsIgnoreCase("slow"))
				moptopConfig.setRotorSpeed(XMoptopInstrumentConfig.ROTOR_SPEED_SLOW);
			else if(rotorSpeedString.equalsIgnoreCase("fast"))
				moptopConfig.setRotorSpeed(XMoptopInstrumentConfig.ROTOR_SPEED_FAST);
			else
			{
				reply = "ERROR ROTOR SPEED " + rotorSpeedString;
				processReply(reply);
				return;
			}
			// filter
			XFilterSpec filters = new XFilterSpec();
			filters.addFilter(new XFilterDef(filterString));
			moptopConfig.setFilterSpec(filters);
			// binning
			try 
			{
				XDetectorConfig detector = new XDetectorConfig();
				int xBin = Integer.parseInt(xBinString);
				detector.setXBin(xBin);
				int yBin = Integer.parseInt(yBinString);
				detector.setYBin(yBin);
				moptopConfig.setDetectorConfig(detector);
			}
			catch (NumberFormatException nx) 
			{
				reply = "ERROR BINNING " + nx;
				processReply(reply);
				return;
			}
			// set instConfig to constructed moptopConfig
			instConfig = moptopConfig;
		} 
		else if (instId.equals("LIRIC")) 
		{
			// LIRIC <nudgematicOffsetSize> <coaddExposureLength> <filter>

			if (parser.countTokens() < 3) 
			{
				reply = "ERROR MISSING_PARAMETERS Use: INSTR <session> LIRIC <nudgematicOffsetSize> <coaddExposureLength> <filter>";
				processReply(reply);
				return;
			}
			// construct config
			XLiricInstrumentConfig liricConfig = new XLiricInstrumentConfig("TOC_LIRIC");
			liricConfig.setInstrumentName("LIRIC");

			// parse command parameters
			String nudgematicOffsetSizeString = parser.nextToken(); 
			String coaddExposureLengthString = parser.nextToken(); 
			String filterString = parser.nextToken();

			// nudgematic offset size
			if(nudgematicOffsetSizeString.equalsIgnoreCase("none"))
				liricConfig.setNudgematicOffsetSize(XLiricInstrumentConfig.NUDGEMATIC_OFFSET_SIZE_NONE);
			else if(nudgematicOffsetSizeString.equalsIgnoreCase("small"))
				liricConfig.setNudgematicOffsetSize(XLiricInstrumentConfig.NUDGEMATIC_OFFSET_SIZE_SMALL);
			else if(nudgematicOffsetSizeString.equalsIgnoreCase("large"))
				liricConfig.setNudgematicOffsetSize(XLiricInstrumentConfig.NUDGEMATIC_OFFSET_SIZE_LARGE);
			else
			{
				reply = "ERROR NUDGEMATIC OFFSET SIZE " + nudgematicOffsetSizeString;
				processReply(reply);
				return;
			}
			// coadd exposure length
			try
			{
				int coaddExposureLength = Integer.parseInt(coaddExposureLengthString);

				liricConfig.setCoaddExposureLength(coaddExposureLength);
			}
			catch (NumberFormatException nx) 
			{
				reply = "ERROR COADD EXPOSURE LENGTH " + nx;
				processReply(reply);
				return;
			}
			// filter
			XFilterSpec filters = new XFilterSpec();
			filters.addFilter(new XFilterDef(filterString));
			liricConfig.setFilterSpec(filters);
			// binning
			XDetectorConfig detector = new XDetectorConfig();
			detector.setXBin(1);
			detector.setYBin(1);
			liricConfig.setDetectorConfig(detector);
			// set instConfig to constructed liricConfig
			instConfig = liricConfig;
		}
		else if (instId.equals("SPRAT")) 
		{
			// SPRAT <slit:in|out> <grism:in|out> <grism:red|blue>
			if (parser.countTokens() < 3) 
			{
				reply = "ERROR MISSING_PARAMETERS Use: INSTR <session> SPRAT <slit:in|out> <grism:in|out> <grism:red|blue>";
				processReply(reply);
				return;
			}
			// construct config
			XImagingSpectrographInstrumentConfig spratConfig = new XImagingSpectrographInstrumentConfig("TOC_SPRAT");
			spratConfig.setInstrumentName("SPRAT");

			// parse command parameters
			String slitPositionString = parser.nextToken(); 
			String grismPositionString = parser.nextToken(); 
			String grismRotationString = parser.nextToken();

			// slit position
			if(slitPositionString.equalsIgnoreCase("in"))
				spratConfig.setSlitPosition(XImagingSpectrographInstrumentConfig.SLIT_DEPLOYED);
			else if(slitPositionString.equalsIgnoreCase("out"))
				spratConfig.setSlitPosition(XImagingSpectrographInstrumentConfig.SLIT_STOWED);
			else
			{
				reply = "ERROR SLIT POSITION " + slitPositionString;
				processReply(reply);
				return;
			}
			// grism position
			if(grismPositionString.equalsIgnoreCase("in"))
				spratConfig.setGrismPosition(XImagingSpectrographInstrumentConfig.GRISM_IN);
			else if(grismPositionString.equalsIgnoreCase("out"))
				spratConfig.setGrismPosition(XImagingSpectrographInstrumentConfig.GRISM_OUT);
			else
			{
				reply = "ERROR GRISM POSITION " + grismPositionString;
				processReply(reply);
				return;
			}

			// grism rotation
			if(grismRotationString.equalsIgnoreCase("red"))
				spratConfig.setGrismRotation(XImagingSpectrographInstrumentConfig.GRISM_NOT_ROTATED);
			else if(grismRotationString.equalsIgnoreCase("blue"))
				spratConfig.setGrismRotation(XImagingSpectrographInstrumentConfig.GRISM_ROTATED);
			else
			{
				reply = "ERROR GRISM ROTATION " + grismRotationString;
				processReply(reply);
				return;
			}

			// binning
			XDetectorConfig detector = new XDetectorConfig();
			detector.setXBin(1);
			detector.setYBin(1);
			spratConfig.setDetectorConfig(detector);
			// set instConfig to constructed spratConfig
			instConfig = spratConfig;
		}

		// check the real instrument id here
		if (instConfig == null) 
		{
			processError("INSTRUMENT", "No instrument matches id: " + instId);
			return;
		}

		InstrumentStatusProvider isp = null;
		try 
		{
			InstrumentDescriptor iid = new InstrumentDescriptor(instId);
			InstrumentRegistry ireg = RCS_Controller.controller.getInstrumentRegistry();
			isp = ireg.getStatusProvider(iid);
		} 
		catch (Exception e) 
		{
			e.printStackTrace();
			processError("INSTRUMENT", "Instrument not found: " + instId);
			return;
		}

		try 
		{
			InstrumentStatus status = isp.getStatus();
			if (!status.isOnline()) 
			{
				processError("INSTRUMENT", instId + " is OFFLINE");
				return;
			}
		} 
		catch (Exception e) 
		{
			e.printStackTrace();
			processError("INSTRUMENT", instId + " unable to determine online status");
			return;
		}

		try 
		{
			InstrumentStatus status = isp.getStatus();
			if (!status.isFunctional()) 
			{
				processError("INSTRUMENT", instId + " is NON-OPERATIONAL");
				return;
			}
		} 
		catch (Exception e) 
		{
			e.printStackTrace();
			processError("INSTRUMENT", instId + " unable to determine operational status");
			return;
		}

		/*
		 * Instrument inst = Instruments.findInstrumentFor(instConfig); if (inst
		 * == null) { processError("INSTRUMENT",
		 * "No instrument available using " + instConfig.getClass().getName());
		 * return; } instId = inst.getName();
		 * 
		 * // check the bugger is working... if (inst.getStatus() ==
		 * Instrument.NETWORK_STATUS_OFFLINE) { processError("INSTRUMENT",
		 * instId + " is OFFLINE"); return; }
		 * 
		 * if (inst.getOperationalStatus() ==
		 * Instrument.OPERATIONAL_STATUS_FAIL) { processError("INSTRUMENT",
		 * instId + " is NON_OPERATIONAL"); return; }
		 */

		TOCInstrumentTask tinst = new TOCInstrumentTask(tocAgent.getName() + "/TOCInstrument", tocAgent, this,
				instConfig);
		if (!tocAgent.addNextJob(tinst)) 
		{
			processError("QUEUE_OVERFLOW", "Too many requests queued - try again later.");			
		} else 
		{
			handlerTask = tinst;
			handlingTime = DEFAULT_HANDLING_OVERHEAD + MAX_CONFIG_TIME;
		}

		// set the currently selected instrument so we know where to send
		// subsequent exposures and stuff...
		selectedInstId = instId;
		currentInstConfig = instConfig;

	}

	public void processCHECK_OPERCommand(StringTokenizer parser) {

		StandardStateModel tsm = RCS_Controller.controller.getTestStateModel();

		// variables
		Map map = tsm.getStateInfo();

		// current state
		int cs = tsm.getIntState();
		int cop = 0;

		String state = "UNKNOWN";
		switch (cs) {
		case 1:
			state = "ENGINEERING";
			break;
		case 5:
			OperationsManager opsMgr = TaskOperations.getInstance().getOperationsManager();

			// current op
			cop = opsMgr.getOperationsState();
			if (cop == 4 || cop == 5)
				state = "OPERATIONAL";
			else
				state = "STANDBY";
			break;
		default:
			state = "STANDBY";
		}

		reply = "OK OpState=" + state + ",opmgr=" + cop;
		processReply(reply);

	}

	/** Process a command. */
	public void processSTATUSCommand(StringTokenizer parser) {

		if (parser.countTokens() < 2) {
			reply = "ERROR MISSING_PARAMETERS Use: STATUS <cat> <key>";
			processReply(reply);
			return;
		}

		String cat = parser.nextToken();
		String key = parser.nextToken();

		if (cat.equals("INTERNAL") && key.equals("operational")) {

			StandardStateModel tsm = RCS_Controller.controller.getTestStateModel();

			// variables
			Map map = tsm.getStateInfo();

			// current state
			int cs = tsm.getIntState();
			int cop = 0;

			String state = "UNKNOWN";
			switch (cs) {
			case 1:
				state = "ENGINEERING";
				break;
			case 5:
				OperationsManager opsMgr = TaskOperations.getInstance().getOperationsManager();

				// current op
				cop = opsMgr.getOperationsState();
				if (cop == 4 || cop == 5)
					state = "OPERATIONAL";
				else
					state = "STANDBY";

				break;
			default:
				state = "STANDBY";
			}

			reply = "OK operational=" + state + ",opmgr=" + cop;
			processReply(reply);

			return;
		}

		LegacyStatusProviderRegistry emm = LegacyStatusProviderRegistry.getInstance();
		if (emm == null)
			reply = "ERROR FATAL EMM Registry not found";
		StatusCategory grabber = null;
		try {
			grabber = emm.getStatusCategory(cat);
		} catch (IllegalArgumentException iax) {
			reply = "ERROR CATEGORY (" + cat + ") not found";
			processReply(reply);
			return;
		}

		// Fudge for Instruments which use quoted strings as keys !!!.
		if (key.indexOf("_") != -1)
			key = key.replace('_', ' ');
		try {
			// This is the real status
			reply = "OK " + key + "=" + grabber.getStatusEntryRaw(key);
			processReply(reply);
			return;
		} catch (IllegalArgumentException iax) {
			reply = "ERROR KEYWORD Key (" + key + ") not found in category " + cat;
			processReply(reply);
			return;
		}

	}

	/** Check that a session is active and that the supplied sessionID is valid. */
	public boolean checkSession(StringTokenizer parser) {

		// Is there a session running.
		if (currentSA == null) {
			processError("NO_CURRENT_SESSION");
			return false;
		}

		// Is a session specified.
		if (parser.countTokens() < 1) {
			processError("SESSIONID_REQUIRED");
			return false;
		}

		// Check the sessionID.
		String sessionId = parser.nextToken();
		if (!sessionId.equals(currentSA.sessionId)) {
			processError("ILLEGAL_SESSION", sessionId);
			return false;
		}

		return true;
	}

	public void processAck(long timeout) {
		if (serverImpl != null)
			serverImpl.sendAck(timeout);
	}

	/** Just calls sendReply() on the attached ServerImpl. */
	public void processReply(String reply) {
		logger.log(1, "Sending reply: "+reply);
		if (serverImpl != null)
			serverImpl.sendReply(reply);
	}

	/** Convenience method for returning errors. */
	public void processError(String errorCode, String message) {
		processReply("ERROR " + errorCode + " " + message + ".");
	}

	/** Convenience method for returning errors. */
	public void processError(String errorCode) {
		processReply("ERROR " + errorCode);
	}

	/** ProtocolImpl will call this if it timesout. */
	public void dispose() {
		if (handlerTask != null) {
			handlerTask.abort();
		}
	}

	/** This method is used to try and abort any attached task (ignore!). */
	public void abort(int code, String message) { 
	}

	public void exceptionOccurred(Object source, Exception exception) {
		System.err.println("TOC_GenericCImpl::Source: " + source + " Exception: " + exception);
		logger.log(1, "Error occured while handling TOCS command: Source: "+source+", Exception: "+exception);
	}

}

/**
 * $Log: TOC_GenericCommandImpl.java,v $ /** Revision 1.7 2008/07/10 09:54:15
 * eng /** added checks for instrument online and operational in INSTR command
 * /** /** Revision 1.6 2008/03/27 12:25:55 snf /** changed instrument selection
 * to lookup instconfig class rather than use supplied name from INST command
 * /** /** Revision 1.5 2008/03/27 11:49:51 snf /** added RISEcam /** /**
 * Revision 1.4 2008/03/18 15:09:14 snf /** added EM0xx to MEROPE instr option
 * /** /** Revision 1.3 2007/10/18 10:24:25 snf /** added ttr test temporarily
 * /** /** Revision 1.2 2007/06/26 07:16:07 snf /** added merope as instrument
 * option /** /** Revision 1.1 2006/12/12 08:32:07 snf /** Initial revision /**
 * /** Revision 1.1 2006/05/17 06:35:48 snf /** Initial revision /** /**
 * Revision 1.2 2002/09/16 09:38:28 snf /** *** empty log message *** /** /**
 * Revision 1.1 2001/09/03 15:28:40 snf /** Initial revision /** /** Revision
 * 1.1 2001/06/08 16:27:27 snf /** Initial revision /**
 */
